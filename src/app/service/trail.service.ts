import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { forkJoin, Observable } from 'rxjs';
import { of } from 'rxjs';
import {Trail, TrailMeta} from '../type/trail';
import { LocalStorageService } from 'ngx-webstorage';
import { LoaderService } from './loader.service';
import { TrailGeneratorService } from './trail-generator.service';
import { Waypoint } from '../type/waypoint';
import { Poi } from '../type/poi';
import { SnowGeneratorService } from './snow-generator.service';
import { parseSnow, reverseSnow } from '../_util/snow';

// dynamically called
import { parsePCTData } from '../parser/pct-data';
import { parseDEMOData } from '../parser/demo-data';
import { parseCDTData } from '../parser/cdt-data';
import { parseATData } from '../parser/at-data';
import {environment} from '../../environments/environment.prod';
import {getTrailMetaDataById} from '../_util/trail';

@Injectable({
  providedIn: 'root'
})

/* 3 options
- get the locally stored (user downloaded) combined trail file (that includes trail & poi), 2 separate JSONs, nobo/sobo
- get the default combined file (from assets, baked into the app), 2 separate JSONs, nobo/sobo
- get raw data and parse it to create a new combined trail file (only for developers), requires environment settings
the same applies to a seperate snow data file (single file, not direction specific), which is parsed upon download
but can also be generated by devs */
export class TrailService {

  // prevent removal of dynamically used imports (tree shaking), see: https://github.com/Microsoft/TypeScript/issues/9191
  // since each dataset has a different source, they all have their own parsing routine, before step 2 (generateMiles() / parseSnow())
  private _parseDEMOData:   Function = parseDEMOData;
  private _parsePCTData:    Function = parsePCTData;
  private _parseCDTData:    Function = parseCDTData;
  private _parseATData:     Function = parseATData;

  constructor(
    private _http: HttpClient,
    private _localStorage: LocalStorageService,
    private _loaderService: LoaderService,
    private _trailGenerator: TrailGeneratorService,
    private _snowGenerator: SnowGeneratorService
  ) {}

  // Get raw trail data, for parsing (dev mode)
  // this generates the preparsed data files to be used by regular users (stored online for download + default version in assets)
  public getRawTrailData(trailId: number): Observable<object> {

    let _trailMeta: TrailMeta;

    for (const key in environment.TRAILS_GENERATION) {
      if (environment.TRAILS_GENERATION[key].id === trailId) {
        _trailMeta = environment.TRAILS_GENERATION[key] as TrailMeta;
      }
    }

    const _metaAsObservable = of(_trailMeta);     // so it can be passed into the forkjoin

    // AT data from the ATC
    // PCT data from halfmile
    // CDT data from CDTC (might be able to get better dataset)
    // snow data ripped from postholer (not very nice, I know)

    // .dat is an xml structured file (so .gpx or .kml)
    const _assetsDir: string = 'assets/data/';
    const _trail = this._http.get(_assetsDir + _trailMeta.dataPath + 'trail.dat', {responseType: 'text'});
    const _poi = this._http.get(_assetsDir + _trailMeta.dataPath + 'poi.dat', {responseType: 'text'});
    const _snow = this._http.get(_assetsDir + _trailMeta.dataPath + 'snow.json', {responseType: 'json'});

    return forkJoin([_metaAsObservable, _trail, _poi, _snow]);
  }

  // Get the pre parsed trail data (regular user), returns a promise
  public getPreParsedTrailData(trailId: number, direction: number): Observable<object> {

    this._loaderService.showMessage('fetching trail data');

    const _trailMeta = getTrailMetaDataById(trailId);

    const _directionString: string = (direction === 0) ? 'nobo' : 'sobo';

    let _combinedData;
    let _snowData;

    const _locallyStored = false;

    if (_locallyStored) {

      // todo XXX get file from local storage (or else get default from assets), capacitor/cordova file

      // needs some sort of error handling (funct at bottom)

    } else {

      _combinedData = this._http.get('assets/files/' + _trailMeta.abbr + '/trail-' + _directionString + '.json'
        , {responseType: 'json'});

      _snowData = this._http.get('assets/files/' + _trailMeta.abbr + '/snow.json'
        , {responseType: 'json'});
    }

    return forkJoin([_combinedData, _snowData]);
  }

  // Parse the raw data (routines for each trail), returns a promise
  public parseTrailData(trail: TrailMeta, waypoints: string, pois: string, snow: object, direction: number): object {

    this._loaderService.showMessage('parsing trail data');

    // dynamic function call
    const _parsed = this['_parse' + trail.abbr + 'Data'](trail, waypoints, pois, snow, direction);

    const _trail = this._trailGenerator.generateMiles(
      _parsed[0] as TrailMeta,
      _parsed[1] as  Array<Waypoint>,
      _parsed[2] as Array<Poi>,
      direction
    );

    let _snow = parseSnow(_parsed[3], _trail.id, _trail.abbr, trail.snowVersion);

    if (direction === 1) {
      _snow = reverseSnow(_snow, _trail.miles.length);
    }

    this._snowGenerator.setSnowData(_snow);

    return {trail: _trail, snow: _snow};
  }

  // handleError(error: HttpErrorResponse): void {
  //   if (error.error instanceof ErrorEvent) {
  //     console.error('An error occurred:', error.error.message);
  //   } else {
  //     console.error(`Backend returned code ${error.status}`);
  //   }
  //   // return throwError('Something bad happened; please try again later.');
  //   // TODO: show popup with retry button
  // }
}
