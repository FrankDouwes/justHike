import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { forkJoin, Observable } from 'rxjs';
import { of } from 'rxjs';
import { Trail } from '../type/trail';
import { LocalStorageService } from 'ngx-webstorage';
import { LoaderService } from './loader.service';
import { TrailGeneratorService } from './trail-generator.service';
import { Waypoint } from '../type/waypoint';
import { Poi } from '../type/poi';
import { getTrailDataById } from '../_util/trail';
import { SnowGeneratorService } from './snow-generator.service';
import { parseSnow, reverseSnow } from '../_util/snow';

// dynamically called
import { parsePCTData } from '../parser/pct-data';
import { parseDEMOData } from '../parser/demo-data';
import { parseCDTData } from '../parser/cdt-data';
import { parseATData } from '../parser/at-data';

@Injectable({
  providedIn: 'root'
})

/* 3 options
- get the locally stored (user downloaded) combined trail file (that includes trail & poi)
- get the default combined file (from assets, baked into the app)
- get raw data and parse it to create a new combined trail file (only for developers)
the same applies to a seperate snow data file, which is parsed upon download, but can also be generated by devs*/

export class TrailService {

  // prevent removal of dynamically used imports, see: https://github.com/Microsoft/TypeScript/issues/9191
  private _parseDEMOData: Function = parseDEMOData;
  private _parsePCTData: Function = parsePCTData;
  private _parseCDTData: Function = parseCDTData;
  private _parseATData: Function = parseATData;

  constructor(
    private _http: HttpClient,
    private _localStorage: LocalStorageService,
    private _loaderService: LoaderService,
    private _trailGenerator: TrailGeneratorService,
    private _snowGenerator: SnowGeneratorService
  ) {}

  // Get raw trail data, for parsing (dev mode
  public getRawTrailData(trailId: number): Observable<object> {

    this._loaderService.showMessage('fetching raw trail data');

    const _trailMeta = getTrailDataById(trailId);
    const _metaAsObservable = of(_trailMeta);     // so it can be passed into the forkjoin

    const _trail = this._http.get('assets/data/' + _trailMeta.dataPath + 'trail.gpx', {responseType: 'text'});
    const _poi = this._http.get('assets/data/' + _trailMeta.dataPath + 'poi.gpx', {responseType: 'text'});
    const _snow = this._http.get('assets/data/' + _trailMeta.dataPath + 'snow.json', {responseType: 'json'});

    // TODO: needs error handling ???

    return forkJoin([_metaAsObservable, _trail, _poi, _snow]);
  }

  // Get the pre parsed trail data (regular user), returns a promise
  public getPreParsedTrailData(trailId: number, direction: number): Observable<object> {

    this._loaderService.showMessage('fetching trail data');

    const _trailMeta = getTrailDataById(trailId);

    const _directionString: string = (direction === 0) ? 'nobo' : 'sobo';

    let _combinedData;
    let _snowData;

    const _locallyStored = false;

    if (_locallyStored) {

      // todo XXX get file from local storage (or else get default from assets)

    } else {

      _combinedData = this._http.get('assets/files/' + _trailMeta.abbr + '/' + _trailMeta.abbr + '-trail-' + _directionString + '.json'
        , {responseType: 'json'});

      _snowData = this._http.get('assets/files/' + _trailMeta.abbr + '/' + _trailMeta.abbr + '-snow.json'
        , {responseType: 'json'});
    }

    return forkJoin([_combinedData, _snowData]);
  }

  // Parse the raw data (routines for each trail), returns a promise
  public parseTrailData(trail: Trail, waypoints: string, pois: string, snow: object, direction: number): object {

    this._loaderService.showMessage('parsing trail data');

    const _parsed = this['_parse' + trail.abbr + 'Data'](trail, waypoints, pois, snow, direction);

    const _trail = this._trailGenerator.generateMiles(
      _parsed[0] as Trail,
      _parsed[1] as  Array<Waypoint>,
      _parsed[2] as Array<Poi>,
      direction
    );

    let _snow = parseSnow(_parsed[3], _trail.id, _trail.abbr);

    if (direction === 1) {
      _snow = reverseSnow(_snow, trail.miles.length)
    }

    this._snowGenerator.setSnowData(_snow);

    return {trail: _trail, snow: _snow};
  }

  // handleError(error: HttpErrorResponse): void {
  //   if (error.error instanceof ErrorEvent) {
  //     console.error('An error occurred:', error.error.message);
  //   } else {
  //     console.error(`Backend returned code ${error.status}`);
  //   }
  //   // return throwError('Something bad happened; please try again later.');
  //   // TODO: show popup with retry button
  // }
}
